# MLFflow logging utilities.
from pathlib import Path
import base64
import html
from contextlib import redirect_stdout
from io import StringIO

from PIL import Image
import io
from urllib.parse import quote

import mlflow
import logging
from pytorch_lightning.loggers import MLFlowLogger, Logger

from src.utils import pylogger

log = pylogger.RankedLogger(__name__)


def log_plots_to_mlflow(
    trainer,
    ckpt_name: str,
    cb_name: str,
    plot_folder: Path,
    log_raw: bool = True,
    gallery_name: str = None,
):
    """Logs the plots generated by this callback to MLFlow."""
    mlflow_logger = get_mlflow_logger(trainer)
    if mlflow_logger is None:
        return

    arti_dir = resolve_arti_dir(trainer, cb_name, ckpt_name)
    gallery_dir = arti_dir.parent

    # Log each image in the given plot_folder as an artifact.
    if log_raw:
        log_raw_imgs_to_mlflow(plot_folder, mlflow_logger, arti_dir)

    # Generate an html gallery of the logs plots in the parent dir of the arti.
    if gallery_name:
        _ = make_gall(mlflow_logger, plot_folder, gallery_dir, ckpt_name, gallery_name)

    if not log_raw and not gallery_name:
        log.warn(
            f"log_plots_to_mlflow was called with log_raw={log_raw} and "
            f"gallery_name={gallery_name}. Hence, nothing is logged to mlflow for the "
            f"callback that tracks {cb_name}."
        )


def log_raw_imgs_to_mlflow(plot_folder: Path, logger: MLFlowLogger, arti: Path):
    """Logs a directory of images to mlflow, in the artifact directory at arti."""
    IMG_EXTS = {".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg"}
    for img_path in sorted(plot_folder.glob("*")):
        if img_path.suffix.lower() in IMG_EXTS and img_path.is_file():
            logger.experiment.log_artifact(
                run_id=logger.run_id,
                local_path=str(img_path),
                artifact_path=str(arti),
            )


def get_mlflow_logger(trainer) -> MLFlowLogger:
    """Extract the MLFlow logger from the trainer, if it is being used."""
    logger = trainer.logger
    if isinstance(logger, MLFlowLogger):
        return logger

    if isinstance(logger, Logger):
        return None

    for logger in getattr(trainer, "loggers", []) or []:
        if isinstance(logger, MLFlowLogger):
            return logger

    return None


def make_gall(
    mlflow_logger: Logger, plots_dir: Path, gallery_dir: Path, sec_name: str, fname
) -> str:
    """Makes an index html file in mlflow and adds the plots in plots_dir to it.

    If index.html already exists at the given gallery_dir path, then append the plots
    to it rather than generate the file from scratch.

    :param mlflow_logger: The mlflow logger object used in the current run.
    :param plots_dir: The directory where the plots to be put in the html page are.
    :param gallery_dir: The path inside the mlflow artifacts directory structure where
        the index.html containing the plots gallery should go. Generally this should be
        in the parent directory where the plots are stored.
    """
    plots_dir = plots_dir.resolve()
    image_paths = get_image_paths(plots_dir, sec_name)

    # Check if index file already exists.
    index_exists = check_html_exists(mlflow_logger, gallery_dir, f"{fname}.html")
    if index_exists:
        html_page = get_html_page(mlflow_logger, gallery_dir, f"{fname}.html")
    else:
        html_page = generate_gallery_header()

    html_page += write_gallery_section(mlflow_logger, sec_name, image_paths)
    html_page = "\n".join(html_page)

    mlflow_logger.experiment.log_text(
        mlflow_logger.run_id, html_page, artifact_file=gallery_dir / f"{fname}.html"
    )

    return html_page


def check_html_exists(mlflow_logger: Logger, gallery_dir: Path, fname: str) -> bool:
    """Checks if the index.html already exists at the given gallery_dir.

    If it exists, append to the gallery path instead of rewriting the file.
    """
    run_id = mlflow_logger.run_id
    arti_files = mlflow_logger.experiment.list_artifacts(run_id, path=str(gallery_dir))
    file_path = gallery_dir / fname
    file_exists = any([file.path == str(file_path) for file in arti_files])
    return file_exists


def get_html_page(mlflow_logger: Logger, gallery_dir: Path, fname: str) -> list[str]:
    """Read fname.html html page from gallery_dir."""
    logging.getLogger("mlflow").setLevel(logging.ERROR)
    run = mlflow_logger.experiment.get_run(mlflow_logger.run_id)
    artifact_uri = run.info.artifact_uri.rstrip("/")
    file_path = (gallery_dir / fname).as_posix()
    file_path = f"{artifact_uri}/{file_path}"
    with redirect_stdout(StringIO()):
        html_page = mlflow.artifacts.load_text(file_path)
    html_page = html_page.splitlines()

    return html_page


def get_image_paths(plots_dir: Path, section_name: str):
    """Get paths to images contained in a root directory, grouped by subfolder."""
    image_paths = []
    IMG_EXTS = {".png", ".jpg", ".jpeg", ".gif", ".webp", ".svg"}
    for img_path in plots_dir.glob("*"):
        if img_path.suffix.lower() in IMG_EXTS and img_path.is_file():
            image_paths.append(img_path)

    image_paths = sorted(image_paths)

    return image_paths


def generate_gallery_header():
    """Generate the header for the html file."""
    html_header = [
        "<!doctype html>",
        "<meta charset='utf-8'>",
        f"<title>PLOTS</title>",
        "<style>",
        "body{font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:20px}",
        "h1{font-size:20px;margin:0 0 12px}",
        "details{margin:12px 0;border:1px solid #ddd;border-radius:8px;padding:8px}",
        "summary{cursor:pointer;font-weight:600}",
        ".grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(340px,1fr));gap:8px;margin-top:8px}",
        ".card{border:1px solid #eee;border-radius:8px;padding:6px;overflow:hidden;background:#fff}",
        ".card img {width:100%;height:300px;object-fit:contain;display:block;cursor:pointer}",
        ".caption{font-size:12px;margin-top:4px;word-break:break-all;color:#444}",
        "#lightbox{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:10000}",
        "#lightbox.open{display:flex}",
        "#lightbox img{max-width:96vw;max-height:92vh;box-shadow:0 0 15px #000;border-radius:4px}",
        "#lightbox-close{position:absolute;top:12px;right:20px;color:white;font-size:28px;cursor:pointer;font-weight:bold}",
        "</style>",
        "<script>",
        "function openLightbox(src){",
        "  const lb = document.getElementById('lightbox');",
        "  document.getElementById('lightbox-img').src = src;",
        "  lb.classList.add('open');",
        "}",
        "function closeLightbox(){",
        "  document.getElementById('lightbox').classList.remove('open');",
        "}",
        "document.addEventListener('keydown', function(e){",
        "  if(e.key === 'Escape') closeLightbox();",
        "});",
        "</script>",
        # Lightbox markup
        "<div id='lightbox' onclick='closeLightbox()'>",
        "  <span id='lightbox-close' onclick='closeLightbox()'>&times;</span>",
        "  <img id='lightbox-img' src='' onclick='event.stopPropagation()'>",
        "</div>",
        f"<h1>PLOTS</h1>",
    ]

    return html_header


def write_gallery_section(
    mlflow_logger: Logger, section: str, image_paths: list[Path, ...]
) -> list[str, ...]:
    """Write a section of the index html file generated in build_html.

    A section is made up of compressed small image thumbnail that expand when clicked.
    The quality is kept low to ensure that the html page is not too big in terms of
    memory. If the html page is larger than 50 Mb, mlflow does not display it.
    """
    html_section = []
    html_section.append(
        f"<details open><summary>{html.escape(section)} ({len(image_paths)})</summary>"
    )
    html_section.append("<div class='grid'>")
    for img_path in image_paths:
        caption = img_path.stem
        cap = html.escape(caption)
        thumb_src = html.escape(generate_thumbnail(img_path))

        html_section.append(
            "<div class='card'>"
            f"<img loading='lazy' src='{thumb_src}' alt='{cap}' "
            f"onclick='openLightbox(this.src)'>"
            f"<div class='caption'>{cap}</div>"
            "</div>"
        )

    html_section.append("</div></details>")

    return html_section


def generate_thumbnail(path: Path, max_size: int = 1024, quality: int = 30) -> str:
    """Generate the thumbnail that goes into the gallery."""
    ext = path.suffix.lower()
    img = Image.open(path)

    # Create a small thumbnail in-place
    img.thumbnail((max_size, max_size), Image.LANCZOS)

    # Prepare buffer
    buf = io.BytesIO()

    if ext in {".jpg", ".jpeg"}:
        # Ensure RGB (JPEG doesn't support transparency)
        if img.mode in ("RGBA", "P"):
            img = img.convert("RGB")
        mime = "image/jpeg"
        img.save(buf, format="JPEG", quality=quality, optimize=True)
    elif ext in {".png", ".gif", ".webp"}:
        mime = {".png": "image/png", ".gif": "image/gif", ".webp": "image/webp"}[ext]
        img.save(buf, format=img.format or "PNG", optimize=True)
    else:
        mime = "image/png"
        if img.mode in ("RGBA", "P"):
            img = img.convert("RGBA")
        img.save(buf, format="PNG", optimize=True)

    b64 = base64.b64encode(buf.getvalue()).decode("ascii")
    return f"data:{mime};base64,{b64}"


def resolve_arti_dir(trainer, cb_name: str, ckpt_name: str = None):
    """Resolve the artifacts directory where the plots will be stored in mlflow."""
    arti_dir = Path()
    if trainer.strat_name:
        arti_dir = arti_dir / trainer.strat_name / cb_name
    if trainer.metric_name:
        arti_dir = arti_dir / trainer.metric_name
    if trainer.criterion_name:
        arti_dir = arti_dir / trainer.criterion_name
    if arti_dir == Path():
        arti_dir = arti_dir / cb_name
    if ckpt_name is None or ckpt_name in arti_dir.parts:
        return arti_dir

    return arti_dir / ckpt_name
